/**
 * Export Service
 * Handles PDF, Excel, and image export functionality
 */

import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
import * as XLSX from 'xlsx';
import { Bottle, Lineup } from '@/types';

interface ExportOptions {
  includeSpecifications?: boolean;
  includeVisual?: boolean;
}

export const exportService = {
  /**
   * Generate PDF report
   */
  async generatePDF(
    lineup: Lineup, 
    bottles: Bottle[], 
    options: ExportOptions = {}
  ): Promise<Blob> {
    const { includeSpecifications = true, includeVisual = true } = options;
    const doc = new jsPDF();
    
    // Header
    doc.setFontSize(20);
    doc.setTextColor(59, 130, 246); // Primary blue
    doc.text('PACK2 - Lineup Report', 20, 20);
    
    // Lineup info
    doc.setFontSize(12);
    doc.setTextColor(0, 0, 0);
    doc.text(`Lineup: ${lineup.name}`, 20, 35);
    doc.text(`Category: ${lineup.category}`, 20, 42);
    doc.text(`Created: ${new Date(lineup.createdAt).toLocaleDateString()}`, 20, 49);
    doc.text(`Rating: ${'★'.repeat(lineup.rating)}${'☆'.repeat(5 - lineup.rating)}`, 20, 56);
    
    // Settings summary
    doc.setFontSize(10);
    doc.setTextColor(100, 100, 100);
    doc.text(`Algorithm: ${lineup.settings.sortAlgorithm} | Direction: ${lineup.settings.sortDirection}`, 20, 65);
    doc.text(`Shelf: ${lineup.shelfWidth}mm × ${lineup.shelfDepth}mm | Spacing: ${lineup.settings.spacing}mm`, 20, 72);
    
    let yPosition = 85;
    
    // Bottle specifications table
    if (includeSpecifications && bottles.length > 0) {
      doc.setFontSize(14);
      doc.setTextColor(0, 0, 0);
      doc.text('Bottle Specifications', 20, yPosition);
      
      const tableData = bottles.map((bottle, index) => [
        (index + 1).toString(),
        bottle.name,
        bottle.shape,
        `${bottle.volume.toFixed(1)} ml`,
        `${bottle.dimensions.height} mm`,
        `${bottle.dimensions.diameter} mm`,
        bottle.capStyle,
        bottle.material
      ]);
      
      autoTable(doc, {
        startY: yPosition + 5,
        head: [['#', 'Name', 'Shape', 'Volume', 'Height', 'Diameter', 'Cap', 'Material']],
        body: tableData,
        theme: 'striped',
        headStyles: { fillColor: [59, 130, 246] },
        styles: { fontSize: 8 },
      });
      
      yPosition = (doc as any).lastAutoTable.finalY + 15;
    }
    
    // Detailed dimensions table
    if (includeSpecifications && bottles.length > 0 && yPosition < 200) {
      doc.setFontSize(14);
      doc.text('Detailed Dimensions', 20, yPosition);
      
      const detailData = bottles.map((bottle) => [
        bottle.name,
        `${bottle.dimensions.bodyHeight}`,
        `${bottle.dimensions.neckHeight}`,
        `${bottle.dimensions.neckDiameter}`,
        `${bottle.dimensions.shoulderCurveRadius}`,
        `${bottle.dimensions.wallThickness}`,
        bottle.dimensions.neckFinish
      ]);
      
      autoTable(doc, {
        startY: yPosition + 5,
        head: [['Name', 'Body H', 'Neck H', 'Neck Ø', 'Shoulder R', 'Wall', 'Finish']],
        body: detailData,
        theme: 'striped',
        headStyles: { fillColor: [59, 130, 246] },
        styles: { fontSize: 8 },
      });
      
      yPosition = (doc as any).lastAutoTable.finalY + 15;
    }
    
    // Notes
    if (lineup.notes && yPosition < 250) {
      doc.setFontSize(12);
      doc.text('Notes:', 20, yPosition);
      doc.setFontSize(10);
      doc.setTextColor(80, 80, 80);
      
      const splitNotes = doc.splitTextToSize(lineup.notes, 170);
      doc.text(splitNotes, 20, yPosition + 7);
    }
    
    // Footer
    doc.setFontSize(8);
    doc.setTextColor(150, 150, 150);
    doc.text(
      `Generated by PACK2 on ${new Date().toLocaleString()}`,
      20,
      doc.internal.pageSize.height - 10
    );
    
    return doc.output('blob');
  },
  
  /**
   * Generate Excel spreadsheet
   */
  generateExcel(lineup: Lineup, bottles: Bottle[]): Blob {
    const workbook = XLSX.utils.book_new();
    
    // Summary sheet
    const summaryData = [
      ['PACK2 Lineup Export'],
      [],
      ['Lineup Name', lineup.name],
      ['Category', lineup.category],
      ['Total Bottles', bottles.length],
      ['Created', new Date(lineup.createdAt).toISOString()],
      ['Rating', lineup.rating],
      [],
      ['Settings'],
      ['Sort Algorithm', lineup.settings.sortAlgorithm],
      ['Sort Direction', lineup.settings.sortDirection],
      ['Spacing (mm)', lineup.settings.spacing],
      ['Alignment', lineup.settings.alignment],
      [],
      ['Shelf Dimensions'],
      ['Width (mm)', lineup.shelfWidth],
      ['Depth (mm)', lineup.shelfDepth],
      ['Height (mm)', lineup.shelfHeight],
      [],
      ['Notes'],
      [lineup.notes || 'No notes'],
    ];
    const summarySheet = XLSX.utils.aoa_to_sheet(summaryData);
    XLSX.utils.book_append_sheet(workbook, summarySheet, 'Summary');
    
    // Bottles sheet
    const bottleData = bottles.map(bottle => ({
      'Name': bottle.name,
      'Shape': bottle.shape,
      'Volume (ml)': bottle.volume,
      'Height (mm)': bottle.dimensions.height,
      'Body Height (mm)': bottle.dimensions.bodyHeight,
      'Diameter (mm)': bottle.dimensions.diameter,
      'Neck Height (mm)': bottle.dimensions.neckHeight,
      'Neck Diameter (mm)': bottle.dimensions.neckDiameter,
      'Shoulder Radius (mm)': bottle.dimensions.shoulderCurveRadius,
      'Wall Thickness (mm)': bottle.dimensions.wallThickness,
      'Neck Finish': bottle.dimensions.neckFinish,
      'Cap Style': bottle.capStyle,
      'Material': bottle.material,
      'Body Color': bottle.bodyColor,
      'Cap Color': bottle.capColor,
      'Opacity': bottle.opacity,
      'Surface Area (cm²)': bottle.surfaceArea,
    }));
    const bottleSheet = XLSX.utils.json_to_sheet(bottleData);
    XLSX.utils.book_append_sheet(workbook, bottleSheet, 'Bottles');
    
    // Positions sheet
    const positionData = lineup.positions.map((pos, index) => {
      const bottle = bottles.find(b => b.id === pos.bottleId);
      return {
        'Position': index + 1,
        'Bottle Name': bottle?.name || 'Unknown',
        'Volume (ml)': bottle?.volume || 0,
        'X Position (mm)': pos.x,
        'Y Position (mm)': pos.y,
        'Rotation (°)': pos.rotation,
        'Locked': pos.locked ? 'Yes' : 'No',
      };
    });
    const positionSheet = XLSX.utils.json_to_sheet(positionData);
    XLSX.utils.book_append_sheet(workbook, positionSheet, 'Positions');
    
    // Volume analysis sheet
    const volumes = bottles.map(b => b.volume).sort((a, b) => a - b);
    const totalVolume = volumes.reduce((sum, v) => sum + v, 0);
    const avgVolume = totalVolume / volumes.length;
    
    const analysisData = [
      ['Volume Analysis'],
      [],
      ['Total Volume (ml)', totalVolume],
      ['Average Volume (ml)', avgVolume],
      ['Min Volume (ml)', Math.min(...volumes)],
      ['Max Volume (ml)', Math.max(...volumes)],
      ['Volume Range (ml)', Math.max(...volumes) - Math.min(...volumes)],
      [],
      ['Volume Distribution'],
      ...volumes.map((v, i) => [`Bottle ${i + 1}`, v]),
    ];
    const analysisSheet = XLSX.utils.aoa_to_sheet(analysisData);
    XLSX.utils.book_append_sheet(workbook, analysisSheet, 'Analysis');
    
    const buffer = XLSX.write(workbook, { type: 'array', bookType: 'xlsx' });
    return new Blob([buffer], { 
      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' 
    });
  },
  
  /**
   * Capture canvas as image
   */
  async captureImage(canvas: HTMLCanvasElement): Promise<Blob> {
    return new Promise((resolve, reject) => {
      canvas.toBlob((blob) => {
        if (blob) {
          resolve(blob);
        } else {
          reject(new Error('Failed to capture image'));
        }
      }, 'image/png');
    });
  },
};

export default exportService;
